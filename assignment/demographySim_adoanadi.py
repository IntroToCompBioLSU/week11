#!/usr/bin/env python

# Simulation to model demography on a landscape. This simulation 
# will include:
# - birth
# - death
# - dispersal

# First Version
# - Asexual reproduction
# - Annual generation times
# - Poisson-distributed number of offspring
# - Discrete landscape
# - Max dispersal of 1 grid
# - No diagonal dispersal
# - Equal probability of different directions
# - Non-zero probably of not dispersing
# - Starts in the middle
# - Start size of 50
# - No carrying capacity

# Object types
# - Individuals
# - Landscape
# - Cell

# Each generation first disperses, then reproduces

import numpy.random as nr #loading numpy

# Class Definitions

class landscape: #creating landscape class
    """This class holds all individuals across the landscape"""

    def __init__(self,nRows=5,nCols=5,startSize=50): #setting class (landscape) constructor
        """
        Creates a new grid-based with the number of rows, columns, and 
        starting population size specified by the user.
        """
        self.nRows = nRows
        self.nCols = nCols
        self.startSize = startSize
        self.sections = self.setup(self.nRows,self.nCols) #setup as x and y coordinates
        for _ in range(self.startSize): #for-loop to loop through list 
            self.sections[0][0].individuals.append(ind(myLandscape=self,myCell=self.sections[0][0]))
            #adding the individuals to cells making up the entire landscape
            

    def setup(self,nRows,nCols): #setting up the landscape, creating rows and columns (cells)
        """Sets up the landscape as a list of lists containing cells."""
        land = [] #landscape values will be stored as a list
        for rowNum in range(nRows):
            row = [] #row values will be stored as a list within the landscape
            for colNum in range(nCols):
                row.append(cell(("%d_%d") % (rowNum,colNum))) #the columns are added
            land.append(row) 
        return land #exit function and hand back value of landscape which is list of list (rows, columns)

    def printLandscape(self): #printLandscape method to print cell ID numbers
        """Print all id numbers of cells in landscape"""
        for row in self.sections:
            for col in row:
                print("%d" % (len(col.individuals)), "\t", end="") #number of individuals in a column will be printed
            print("\n") #print new line

class cell: #creating cell class
    """This class represents a grid square on our landscape."""

    def __init__(self,id): #constructor defining components of cell class
        self.id = id
        self.individuals = []

class ind: #creating individual class
    """This class represents individuals in our population."""
    
    def __init__(self,myLandscape,myCell,name="",rowPos=0,colPos=0,disProb=0.5): #class constructor identifying characteristics of individuals
        self.myLandscape = myLandscape
        self.myCell = myCell
        self.name = name
        self.offspring = []
        self.meanOffNum = 2.0
        self.rowPos = rowPos
        self.colPos = colPos
        self.disProb = disProb

    def reproduce(self): #reproduce function/methods
        """Return list of offspring"""
        numOff = nr.poisson(self.meanOffNum) #offspring number is generated by random number drawn by Poisson
        offspringList = [] #offspring value number stored as a list
        for _ in range(numOff):
            offspringList.append(ind()) #offspring added to the offspring list
        return offspringList #exit function and hand back value of offspring list

    def disperse(self): #disperal function defined
        """Move, if necessary, to new cell. disProb is dispersal probability."""
        
        if (nr.random() < self.disProb): #if the random number is less than the dispersal probability then...

            # Middle cell
            if (self.rowPos > 0) & (self.rowPos < self.myLandscape.nRows-1) & (self.colPos > 0) & (self.colPos < self.myLandscape.nCols-1):
                ranNum = nr.random() #if in the cell at the middle
                if (ranNum < 0.25): #if random number is less than 0.25
                    self.rowPos = self.rowPos - 1 #move down 1 row cell position in landscape
                elif (ranNum < 0.5): #if random number is less than 0.5
                    self.rowPos = self.rowPos + 1 #move up 1 row cell position in landscape
                elif (ranNum < 0.75): #if random number is less than 0.75
                    self.colPos = self.colPos - 1 #move left 1 column cell position in landscape
                else:
                    self.colPos = self.colPos + 1 #anything else move right 1 column cell position in landscape

            # Upper left cell
            elif (self.rowPos == 0) & (self.colPos == 0): #if in upper left cell
                ranNum = nr.random()
                if (ranNum < 0.5): #if random number in less than 0.5
                    self.rowPos = self.rowPos + 1 #move up 1 row cell position in landscape
                else:
                    self.colPos = self.colPos + 1 #otherwise, move right 1 column cell position in landscape

            # Left edge cell
            elif (self.rowPos > 0) & (self.rowPos < self.myLandscape.nRows-1) & (self.colPos == 0): #if in left edge cell
                ranNum = nr.random()
                if (ranNum < 0.33): #if random number is less than 0.33
                    self.rowPos = self.rowPos - 1 #move down 1 row cell position in landscape
                elif (ranNum < 0.66): #if random number is less than 0.66
                    self.rowPos = self.rowPos + 1 #move up 1 row cell position in landscape
                else:
                    self.colPos = self.colPos + 1 #otherwise, move right 1 column position in landscape

            # Bottom left cell
            elif (self.rowPos == self.myLandscape.nRows-1) & (self.colPos == 0): #if in bottom left cell
                ranNum = nr.random()
                if (ranNum < 0.5): #if random number is less than 0.5
                    self.rowPos = self.rowPos - 1 #move down 1 row cell position in landscape
                else:
                    self.colPos = self.colPos + 1 #otherwise, move right 1 column cell position in landscape
            
            # Bottom edge cell
            elif (self.rowPos == self.myLandscape.nRows-1) & (self.colPos > 0) & (self.colPos < self.myLandscape.nCols-1): #if in bottom edge cell
                ranNum = nr.random()
                if (ranNum < 0.33): #if random number is less than 0.33
                    self.rowPos = self.rowPos - 1 #move down 1 row cell position in landscape
                elif (ranNum < 0.66): #if random number is less than 0.66
                    self.colPos = self.colPos - 1 #move left 1 column cell position in landscape
                else:
                    self.colPos = self.colPos + 1 #otherwise, move right 1 column cell position in landscape

            # Bottom right cell
            elif (self.rowPos == self.myLandscape.nRows-1) & (self.colPos == self.myLandscape.nCols-1): #if in bottom right cell
                ranNum = nr.random()
                if (ranNum < 0.5): #if random number is less than 0.5
                    self.rowPos = self.rowPos - 1 #move down 1 row cell position in landscape
                else:
                    self.colPos = self.colPos - 1 #otherwise, move left 1 column cell position in landscape

            # Right edge cell
            elif (self.rowPos > 0) & (self.rowPos < self.myLandscape.nRows-1) & (self.colPos == self.myLandscape.nCols-1): #if in right edge cell
                ranNum = nr.random()
                if (ranNum < 0.33): #if random number is less than 0.33
                    self.rowPos = self.rowPos - 1 #move down 1 row cell position in landscape
                elif (ranNum < 0.66): #if random number is less than 0.66
                    self.rowPos = self.rowPos + 1 #move up 1 row cell position in landscape
                else:
                    self.colPos = self.colPos - 1 #otherwise, move left 1 column cell position in landscape

            # Upper right cell
            elif (self.rowPos == 0) & (self.colPos == self.myLandscape.nCols-1): #if in upper right cell
                ranNum = nr.random()
                if (ranNum < 0.5): #if random number is less than 0.5
                    self.rowPos = self.rowPos + 1 #move up 1 row cell position in landscape
                else:
                    self.colPos = self.colPos - 1 #otherwise move left 1 column cell position in landscape

            # Upper edge cell
            else: #if in upper edge cell
                ranNum = nr.random()
                if (ranNum < 0.33): #if random number is less than 0.33
                    self.rowPos = self.rowPos + 1 #move up 1 row cell position in landscape
                elif (ranNum < 0.66): #if random number is less than 0.66
                    self.colPos = self.colPos - 1 #move left 1 column cell position in landscape
                else:
                    self.colPos = self.colPos + 1 #otherwise move right 1 column cell position in landscape

            self.myCell.individuals.remove(self) #moves individuals from initial starting point
            self.myLandscape.sections[self.rowPos][self.colPos].individuals.append(self)
            self.myCell = self.myLandscape.sections[self.rowPos][self.colPos]

# Run demographic simulation

simLandscape = landscape() #running landscape simulation
print("Generation 0:"); print()
simLandscape.printLandscape()

gens = 20 #number of generations is set at 20

for g in range(gens):
    allIndividuals = [] #creates list of all individuals within the matrix of cells making up landscape
    for r in range(simLandscape.nRows):
        for c in range(simLandscape.nCols):
            allIndividuals.extend(simLandscape.sections[r][c].individuals)

    for i in allIndividuals:
        i.disperse() #dispersal of individuals using function that was created

    print("Generation %d:" % (g+1)); print()

    simLandscape.printLandscape() 
#display the entire landscape to the screen
